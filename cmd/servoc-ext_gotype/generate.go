package main

import (
	"os"

	"github.com/dave/jennifer/jen"
	"github.com/egoodhall/servo/pkg/ast"
	"github.com/iancoleman/strcase"
)

func (x *GoStructPlugin) Generate(file *ast.File, options Options) error {
	if !options.Enabled {
		return nil
	}

	content, err := generateFile(file, options)
	if err != nil {
		return err
	}

	f, err := os.OpenFile(options.File, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	defer f.Close()

	return content.Render(f)
}

func generateFile(file *ast.File, options Options) (*jen.File, error) {
	gofile := jen.NewFile(options.Package)
	gofile.PackageComment("Code generated by servoc (gostruct plugin). DO NOT EDIT.")

	for _, message := range file.Messages {
		gofile.Type().Id(strcase.ToCamel(message.Name)).StructFunc(func(g *jen.Group) {
			for _, field := range message.Fields {
				g.Add(renderField(field))
			}
		})
		gofile.Line()
	}

	for _, enum := range file.Enums {
		gofile.Type().Id(strcase.ToCamel(enum.Name)).String()
		gofile.Const().DefsFunc(func(g *jen.Group) {
			for _, value := range enum.Values {
				g.Id(enum.Name + "_" + strcase.ToCamel(value)).Id(strcase.ToCamel(enum.Name)).Op("=").Lit(value)
			}
		})
	}

	for _, union := range file.Unions {
		gofile.Type().Id(strcase.ToCamel(union.Name)).StructFunc(func(g *jen.Group) {
			g.Id(union.Name + "Type").String().Tag(map[string]string{"json": "@type"})
			for _, member := range union.Members {
				g.Id(strcase.ToCamel(member.Name)).
					Op("*").Id(member.Type.Name).
					Tag(map[string]string{"json": member.Name + ",omitempty"})
			}
		}).Line()
	}

	for _, svc := range file.Services {
		gofile.Type().Id(strcase.ToCamel(svc.Name)).InterfaceFunc(func(g *jen.Group) {
			for _, rpc := range svc.Rpcs {
				if rpc.Response != "" {
					g.Id(strcase.ToCamel(rpc.Name)).
						Params(jen.Qual("context", "Context"), getMethodType(rpc.Request)).
						Params(getMethodType(rpc.Response), jen.Error())
				} else {
					g.Id(strcase.ToCamel(rpc.Name)).
						Params(jen.Qual("context", "Context"), getMethodType(rpc.Request)).
						Error()
				}
			}
		}).Line()
	}

	return gofile, nil
}

func renderField(field *ast.Field) *jen.Statement {
	switch ft := field.Type.(type) {
	case ast.ScalarType:
		s := jen.Id(strcase.ToCamel(field.Name))
		if field.Optional {
			s = s.Op("*")
		}
		s.Id(ft.Name).Tag(map[string]string{"json": field.Name})
		return s
	case ast.ListType:
		return jen.Id(strcase.ToCamel(field.Name)).Op("[]").Id(ft.ElementType.Name).Tag(map[string]string{"json": field.Name})
	case ast.MapType:
		return jen.Id(strcase.ToCamel(field.Name)).Map(jen.Id(ft.KeyType.Name)).Id(ft.ValueType.Name).Tag(map[string]string{"json": field.Name})
	}
	return nil
}

func getMethodType(name string) *jen.Statement {
	if ast.IsPrimitive(name) {
		return jen.Id(name)
	}
	return jen.Op("*").Id(name)
}
